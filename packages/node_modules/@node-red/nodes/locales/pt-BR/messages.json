{
    "common": {
        "label": {
            "payload": "Payload",
             "topic": "Tópico",
             "name": "Nome",
             "username": "Nome de usuário",
             "password": "Senha",
             "property": "Propriedade",
             "selectNodes": "Selecionar nós ...",
             "expand": "Expandir"
        },
        "status": {
            "connected": "conectado",
             "not-connected": "não conectado",
             "disconnected": "desconectado",
             "connecting": "conectando",
             "error": "erro",
             "ok": "OK"
        },
        "notification": {
            "error": "<strong> Erro </strong>: __message__",
             "errors": {
                 "not-deployed": "nó não implantado",
                 "no-response": "sem resposta do servidor",
                 "unexpected": "erro inesperado (__status__) __message__"
             }
        },
        "errors": {
            "nooverride": "Aviso: as propriedades do msg não podem mais substituir as propriedades do nó definido. Consulte bit.ly/nr-override-msg-props"
        }
    },
    "inject": {
        "inject": "injetar",
         "injectNow": "injetar agora",
         "repeat": "repita = __repeat__",
         "crontab": "crontab = __crontab__",
         "stopped": "parado",
         "failed": "Injeção falhou: __error__",

        "label": {
            "properties": "Propriedades",
             "repeat": "Repetir",
             "flow": "contexto de fluxo",
             "global": "contexto global",
             "str": "string",
             "num": "numero",
             "bool": "boolean",
             "json": "objeto",
             "bin": "buffer",
             "date": "timestamp",
             "env": "variável env",
             "object": "objeto",
             "string": "string",
             "boolean": "boolean",
             "number": "número",
             "Array": "array",
             "invalid": "Objeto JSON inválido"
        },
        "timestamp": "timestamp",
         "none": "nenhum",
         "interval": "intervalo",
         "interval-time": "intervalo entre tempos",
         "time": "em uma hora específica",
         "seconds": "segundos",
         "minutes": "minutos",
         "hours": "horas",
         "between": "entre",
         "previous": "valor anterior",
         "at": "em",
         "and": "and",
         "every": "todo",
        "days": [
            "Segunda-feira",
            "Terça-feira",
            "Quarta-feira",
            "Quinta-feira",
            "Sexta-feira",
            "Sábado",
            "Domingo"
        ],
         "on": "on",
         "onstart": "Injetar uma vez depois",
         "onceDelay": "segundos, depois",
         "success": "Injetado com sucesso: __label__",
         "errors": {
             "failed": "injeção falhou, consulte o log para obter detalhes",
             "toolong": "Intervalo muito grande",
             "invalid-expr": "Expressão JSONata inválida: __error__"
         }
    },
    "catch": {
        "catch": "catch: todos",
        "catchNodes": "catch: __number__",
        "catchUncaught": "catch: não capturado",
        "label": {
            "source": "Capture erros de",
            "selectAll": "selecionar tudo",
            "uncaught": "Ignorar erros manipulados por outros nós Catch"
        },
        "scope": {
            "all": "todos os nós",
            "selected": "nós selecionados"
        }
    },
    "status": {
        "status": "status: todos",
        "statusNodes": "status: __number__",
        "label": {
            "source": "Status do relatório de",
            "sortByType": "ordenar por tipo"
        },
        "scope": {
            "all": "todos os nós",
            "selected": "nós selecionados"
        }
    },
    "complete": {
        "completeNodes": "completo: __number__"
    },
    "debug": {
        "output": "Saída",
        "status": "status",
        "none": "Nenhum",
        "invalid-exp": "Expressão JSONata inválida: __error__",
        "msgprop": "propriedades da mensagem",
        "msgobj": "objeto msg completo",
        "autostatus": "igual à saída de depuração",
        "to": "Para",
        "debtab": "aba de depuração",
        "tabcon": "guia de depuração e console",
        "toSidebar": "janela de depuração",
        "toConsole": "console do sistema",
        "toStatus": "status do nó (32 caracteres)",
        "severity": "Nível",
        "notification": {
            "activated": "Ativado com sucesso: __label__",
            "deactivated": "Desativado com sucesso: __label__"
        },
        "sidebar": {
            "label": "depurar",

            "name": "mensagens de depuração",
             "filterAll": "todos os nós",
             "filterSelected": "nós selecionados",
             "filterCurrent": "fluxo atual",
             "debugNodes": "Nós de depuração",
             "clearLog": "Limpar log",
             "filterLog": "Log de filtro",
             "openWindow": "Abrir em uma nova janela",
             "copyPath": "Copiar caminho",
             "copyPayload": "Copiar valor",
             "pinPath": "Pin aberto"
        },
        "messageMenu": {
            "collapseAll": "Recolher todos os caminhos",
            "clearPinned": "Limpar caminhos fixados",
            "filterNode": "Filtrar este nó",
            "clearFilter": "Limpar filtro"
        }
    },
    "link": {
        "linkIn": "link entrada",
        "linkOut": "link saída"
    },
    "tls": {
        "tls": "Configuração TLS",
        "label": {
            "use-local-files": "Use a chave e os certificados dos arquivos locais",
             "upload": "Upload",
             "cert": "Certificado",
             "key": "Chave privada",
             "passphrase": "Passphrase",
             "ca": "Certificado CA",
             "verify-server-cert": "Verifique o certificado do servidor",
             "servername": "Nome do servidor",
             "alpnprotocol": "Protocolo ALPN"
        },
        "placeholder": {
            "cert": "caminho para o certificado (formato PEM)",
            "key": "caminho para a chave privada (formato PEM)",
            "ca": "caminho para o certificado CA (formato PEM)",
            "passphrase": "passphrase de chave privada (opcional)",
            "servername": "para uso com SNI",
            "alpnprotocol": "para uso com ALPN"
        },
        "error": {
            "missing-file": "Nenhum certificado / arquivo de chave fornecido"
        }
    },
    "exec": {
        "exec": "exec",
        "spawn": "spawn",

        "label": {
            "command": "Comando",
            "append": "Acrescentar",
            "timeout": "Tempo esgotado",
            "timeoutplace": "opcional",
            "return": "Saída",
            "seconds": "segundos",
            "stdout": "stdout",
            "stderr": "stderr",
            "retcode": "código de retorno",
            "winHide": "Ocultar console"
        },
        "placeholder": {
            "extraparams": "parâmetros de entrada extras"
        },
        "opt": {
            "exec": "quando o comando estiver completo - modo exec",
            "spawn": "enquanto o comando está em execução - modo spawn"
        },
        "oldrc": "Usar saída de estilo antigo (modo de compatibilidade)"
    },
    "function": {
        "function": "",
        "label": {
            "setup": "Configurar",
            "function": "Na mensagem",
            "initialize": "No início",
            "finalize": "Na parada",
            "outputs": "Saídas",
            "modules": "Módulos"
        },
        "text": {
            "initialize": "// O código adicionado aqui será executado uma vez \n // sempre que o nó for iniciado. \n",
             "finalize": "// O código adicionado aqui será executado quando o nó \n // for interrompido ou reimplantado. \n"
        },
        "require": {
            "var": "variável",
             "module": "módulo",
             "moduleName": "Nome do módulo",
             "importAs": "Importar como"
        },
        "error": {
            "externalModuleNotAllowed": "Nó de função não tem permissão para carregar módulos externos",
             "moduleNotAllowed": "Módulo __module__ não permitido",
             "externalModuleLoadError": "Nó de função falhou ao carregar módulos externos",
             "moduleLoadError": "Falha ao carregar o módulo __module__: __error__",
             "moduleNameError": "Nome da variável do módulo inválido: __name__",
             "moduleNameReserved": "Nome da variável reservada: __name__",
             "inputListener": "Não é possível adicionar ouvinte ao evento 'input' dentro da Função",
             "non-message-returned": "Função tentou enviar uma mensagem do tipo __type__"
        }
    },
    "template": {
        "template": "modelo",
        "label": {
            "template": "Modelo",
             "property": "Propriedade",
             "format": "Destaque de sintaxe",
             "syntax": "Formato",
             "output": "Saída como",
             "mustache": "Modelo de bigode",
             "plain": "Texto simples",
             "json": "JSON analisado",
             "yaml": "YAML analisado",
             "none": "nenhum"
        },
        "templatevalue": "Esta é a mensagem transmitida: {{payload}}!"
    },
    "delay": {
        "action": "Ação",
        "for": "Para",
        "delaymsg": "Atrasar cada mensagem",
        "delayfixed": "Atraso corrigido",
        "delayvarmsg": "Substituir atraso com msg.delay",
        "randomdelay": "Atraso aleatório",
        "limitrate": "Limite de taxa",
        "limitall": "Todas as mensagens",
        "limittopic": "Para cada msg.topic",
        "fairqueue": "Envie cada tópico por vez",
        "timedqueue": "Enviar todos os tópicos",
        "milisecs": "Milissegundos",
        "secs": "Segundos",
        "sec": "Segundo",
        "mins": "Minutos",
        "min": "Minuto",
        "hours": "Horas",
        "hour": "Hora",
        "days": "Dias",
        "day": "Dia",
        "between": "Entre",
        "and": "&",
        "rate": "Taxa",
        "msgper": "msg(s) por",
        "dropmsg": "descarte mensagens intermediárias",
        "allowrate": "permitir msg.rate (em ms) para substituir a taxa",
        "label": {
            "delay": "atraso",
            "variable": "variável",
            "limit": "limit",
            "limitTopic": "limite de tópico",
            "random": "random",
            "units" : {
                "second": {
                    "plural" : "Segundos",
                    "singular": "Segundo"
                },
                "minute": {
                    "plural" : "Minutos",
                    "singular": "Minuto"
                },
                "hour": {
                    "plural" : "Horas",
                    "singular": "Hora"
                },
                "day": {
                    "plural" : "Dias",
                    "singular": "Dia"
                }
            }
        },
        "errors": {
            "too-many": "muitas mensagens pendentes em atraso no nó"
        }
    },
    "trigger": {
        "send": "Enviado", 
        "then": "então", 
        "then-send": "eles enviam",
        "output": {
            "string": "a string",
            "number": "o número",
            "existing": "o objeto msg existente",
            "original": "o objeto msg original",
            "latest": "o objeto de mensagem mais recente",
            "nothing": "nada"
        },
        "wait-reset": "aguarde para ser reiniciado",
        "wait-for": "esperar por",
        "wait-loop": "reenviar a cada",
        "for": "Manuseio",
        "bytopics": "each",
        "alltopics": "todas as mensagens",
        "duration": {
            "ms": "Milisegundos",
            "s": "Segundos",
            "m": "Minutos",
            "h": "Horas"
        },
        "extend": "estender o atraso se uma nova mensagem chegar",
        "override": "anular o atraso com msg.delay",
        "second": "enviar segunda mensagem para saída separada",
        "label": {
            "trigger": "gatilho",
             "trigger-block": "trigger & block",
             "trigger-loop": "reenviar a cada",
             "reset": "Reinicialize o gatilho se:",
             "resetMessage": "msg.reset está definida",
             "resetPayload": "msg.payload é igual a",
             "resetprompt": "opcional"
        }
    },
    "comment": {
        "comment": "comentário"
    },
    "unknown": {
        "label": {
            "unknown": "desconhecido"
        },
        "tip": "<p> Este nó é um tipo desconhecido para a sua instalação do Node-RED. </p> <p> <i> Se você implantar com o nó neste estado, sua configuração será preservada, mas o o fluxo não será iniciado até que o tipo ausente seja instalado. </i> </p> <p> Consulte a barra lateral de informações para obter mais ajuda </p> "
    },
    "mqtt": {
        "label": {
            "broker": "Servidor",
            "example": "por exemplo, localhost",
            "output": "Output",
            "qos": "QoS",
            "retain": "Reter",
            "clientid": "ID do cliente",
            "port": "Porta",
            "keepalive": "Mantenha vivo",
            "cleansession": "Usar sessão limpa",
            "cleanstart": "Usar um começo limpo",
            "use-tls": "Usar TLS",
            "tls-config": "Configuração TLS",
            "verify-server-cert": "Verifique o certificado do servidor",
            "compatmode": "Usar suporte MQTT 3.1 legado",
            "userProperties": "Propriedades do usuário",
            "subscriptionIdentifier": "ID de inscrição",
            "flags": "Bandeiras",

            "nl": "Não receber mensagens publicadas por este cliente",
            "rap": "Manter a bandeira da publicação original",
            "rh": "Tratamento de mensagens retidas",
            "rh0": "Enviar mensagens retidas",
            "rh1": "Enviar apenas para novas assinaturas",
            "rh2": "Não enviar",
            "responseTopic": "Tópico de resposta",
            "contentType": "Tipo de conteúdo",
            "correlationData": "Dados de Correlação",
            "expiry": "Expiração (secs)",
            "sessionExpiry": "Expiração da Sessão (secs)",
            "topicAlias": "Apelido",
            "payloadFormatIndicator": "Formato",
            "payloadFormatIndicatorFalse": "bytes não especificados (padrão)",
            "payloadFormatIndicatorTrue": "Mensagem codificada em UTF-8",
            "protocolVersion": "Protocolo",
            "protocolVersion3": "MQTT V3.1 (legado)",
            "protocolVersion4": "MQTT V3.1.1",
            "protocolVersion5": "MQTT V5",
            "topicAliasMaximum": "Alias ​​Max",
            "maximumPacketSize": "Tamanho máximo do pacote",
            "receiveMaximum": "Recebe Max",
            "session": "Sessão",
            "delay": "Atraso"
        },
        "sections-label":{
            "birth-message": "Mensagem enviada na conexão (mensagem de nascimento)",
            "will-message": "Mensagem enviada em uma desconexão inesperada (mensagem de will)",
            "close-message": "Mensagem enviada antes de desconectar (mensagem de fechamento)"
        },
        "tabs-label": {
            "connection": "Conexão",
             "security": "Segurança",
             "messages": "Mensagens"
        },
        "placeholder": {
            "clientid": "Deixe em branco para gerado automaticamente",
            "clientid-nonclean": "Deve ser definido para sessões não limpas",
            "will-topic": "Deixe em branco para desativar a mensagem",
            "birth-topic": "Deixe em branco para desativar a mensagem de nascimento",
            "close-topic": "Deixe em branco para desativar a mensagem de fechamento"
        },
        "state": {
            "connected": "Conectado ao corretor: _ corretor _", 
            "disconnected": "Desconectado do corretor: _ corretor _", 
            "connect-failed": "Falha na conexão com o corretor: __broker__"
        },
        "retain": "Reter",
        "output": {
            "buffer": "um Buffer",
            "string": "uma String",
            "base64": "uma string codificada em Base64",
            "auto": "detecção automática (string ou buffer)",
            "json": "um objeto JSON analisado"
        },
        "true": "true",
        "false": "false",
        "tip": "Dica: deixe o tópico, qos ou retenha em branco se quiser defini-los por meio das propriedades da mensagem.",

        "errors": {
            "not-defined": "tópico não definido",
            "missing-config": "configuração do corretor ausente",
            "invalid-topic": "Tópico inválido especificado",
            "nonclean-missingclientid": "Nenhum ID de cliente definido, usando sessão limpa",
            "invalid-json-string": "String JSON inválida",
            "invalid-json-parse": "Falha ao analisar string JSON"
        }
    },
    "httpin": {
        "label": {
            "method": "Método",
            "url": "URL",
            "doc": "Documentos",
            "return": "Retorno",
            "upload": "Aceitar uploads de arquivos?",
            "status": "Código de status",
            "headers": "Cabeçalhos",
            "other": "outro",
            "paytoqs" : {
                "ignore": "Ignorar",
                "query": "Anexar aos parâmetros de string de consulta",
                "body": "Enviar como corpo do pedido"
            },
            "utf8String": "string UTF8",
            "binaryBuffer": "buffer binário",
            "jsonObject": "objeto JSON analisado",
            "authType": "Tipo",
            "bearerToken": "Token"
        },
        "setby": "- definido por msg.method -",
        "basicauth": "Usar autenticação",
        "use-tls": "Ativar conexão segura (SSL / TLS)",
        "tls-config": "Configuração TLS",
        "basic": "autenticação básica",
        "digest": "processar autenticação",
        "bearer": "autenticação do portador",
        "use-proxy": "Use proxy",
        "persist": "Habilitar conexão keep-alive",
        "proxy-config": "Configuração de proxy",
        "use-proxyauth": "Usar autenticação de proxy",
        "noproxy-hosts": "Ignorar hosts",
        "utf8": "uma string UTF-8",
        "binary": "um buffer binário",
        "json": "um objeto JSON analisado",
        "tip": {
            "in": "O url será relativo a",
            "res": "As mensagens enviadas para este nó <b> devem </b> ser originadas de um nó <i> http input </i>",
            "req": "Dica: Se a análise JSON falhar, a string buscada é retornada como está."
        },
        "httpreq": "requisição http",
        "errors": {
            "not-created": "Não é possível criar o nó http-in quando httpNodeRoot definido como false",
            "missing-path": "missing path",
            "no-response": "Objeto sem resposta",
            "json-error": "Erro de análise JSON",
            "no-url": "Nenhum url especificado",
            "deprecated-call": "Chamada descontinuada para __method__",
            "invalid-transport": "transporte não http solicitado",
            "timeout-isnan": "O valor do tempo limite não é um número válido, ignorando",
            "timeout-isnegative": "O valor do tempo limite é negativo, ignorando",
            "invalid-payload": "payload inválido"
        },
        "status": {
            "requesting": "solicitando"
        }
    },
    "websocket": {
        "label": {
            "type": "Tipo",
            "path": "Caminho",
            "url": "URL"
        },
        "listenon": "Ouça",
        "connectto": "Conectar-se a",
        "sendrec": "Enviar / Receber",
        "payload": "payload",
        "message": "mensagem inteira",
        "sendheartbeat": "Enviar pulso",
        "tip": {
            "path1": "Por padrão, <code> payload </code> conterá os dados a serem enviados ou recebidos de um websocket. O listener pode ser configurado para enviar ou receber todo o objeto de mensagem como uma string formatada em JSON. ",
            "path2": "Este caminho será relativo a <code> __path__ </code>.",
            "url1": "O URL deve usar o esquema ws: & # 47; & # 47; ou wss: & # 47; & # 47; e apontar para um ouvinte de websocket existente.",
            "url2": "Por padrão, <code> payload </code> conterá os dados a serem enviados ou recebidos de um websocket. O cliente pode ser configurado para enviar ou receber todo o objeto de mensagem como uma string formatada em JSON. "
        },
        "status": {
            "conectado": "conectado __conta__",
            "conectado_plural": "conectado __conta__"
        },
        "errors": {
            "connect-error": "Ocorreu um erro na conexão ws:",
            "send-error": "Ocorreu um erro ao enviar:",
            "missing-conf": "Configuração do servidor ausente",
            "duplicate-path": "Não é possível ter dois ouvintes WebSocket no mesmo caminho: __path__"
        }
    },
    "watch": {
        "watch": "Observar",
        "label": {
            "files": "Arquivo(s)",
            "recursive": "Observe os subdiretórios recursivamente"
        },
        "placeholder": {
            "files": "Lista separada por vírgulas de arquivos e / ou diretórios"
        },
        "tip": "No Windows você deve usar barras duplas \\\\ em qualquer nome de diretório."
    },
    "tcpin": {
        "label": {
            "type": "Tipo",
            "output": "Saída",
            "port": "porta",
            "host": "na hospedagem",
            "payload": "carga(s)",
            "delimited": "delimitado por",
            "close-connection": "Fechar a conexão após o envio de cada mensagem?",
            "decode-base64": "Decodificar mensagem Base64?",
            "server": "Servidor",
            "return": "Retornar",
            "ms": "ms",
            "chars": "caracteres"
        },
        "type": {
            "listen": "Ouça",
            "connect": "Conectar a",
            "reply": "Responder ao TCP"
        },
        "output": {
            "stream": "stream de",
            "single": "único",
            "buffer": "Buffer",
            "string": "String",
            "base64": "String Base64"
        },
        "return": {
            "timeout": "após um tempo limite fixo de",
            "character": "quando o caractere recebido é",
            "number": "um número fixo de caracteres",
            "never": "nunca - mantenha a conexão aberta",
            "immed": "imediatamente - não espere pela resposta"
        },
        "status": {
            "connecting": "conectando a __host __: __ porta__",
            "connected": "conectado a __host __: __ porta__",
            "listening-port": "escutando na porta __port__",
            "stopped-listening": "parou de ouvir na porta",
            "connection-from": "conexão de __host __: __ porta__",
            "connection-closed": "conexão fechada de __host __: __ porta__",
            "connections": "__count__ conexão",
            "connections_plural": "__count__ conexões"

        },
        "errors": {
            "connection-lost": "conexão perdida para __host __: __ porta__",
             "timeout": "tempo limite fechado porta do socket __port__",
             "cannot-listen": "não é possível escutar na porta __port__, erro: __error__",
             "error": "erro: __error__",
             "socket-error": "error de socket __host __: __ port__",
             "no-host": "Host e/ou porta não configurada",
             "connect-timeout": "tempo limite de conexão",
             "connect-fail": "falha de conexão"
        }
    },
    "udp": {
        "label": {
            "listen": "Ouvir",
             "onport": "na porta",
             "using": "usando",
             "output": "Saída",
             "group": "Grupo",
             "interface": "IF Local",
             "send": "Enviar um",
             "toport": "para a porta",
             "address": "Endereço",
             "decode-base64": "Decodificar mensagem transmitida codificada em Base64?"
        },
        "placeholder": {
            "interface": "(opcional) interface local ou endereço para vincular a",
            "interfaceprompt": "(opcional) interface local ou endereço para vincular",
            "address": "ip de destino"
        },
        "udpmsgs": "mensagens udp",
        "mcmsgs": "mensagens multicast",
        "udpmsg": "mensagem udp",
        "bcmsg": "mensagem de transmissão",
        "mcmsg": "mensagem multicast",
        "output": {
            "buffer": "um Buffer",
            "string": "um String",
            "base64": "uma string codificada em Base64"
        },
        "bind": {
            "random": "vincular a porta local aleatória",
            "local": "vincular à porta local",
            "target": "vincular à porta de destino"
        },
        "tip": {
            "in": "Dica: certifique-se de que seu firewall permitirá a entrada de dados.",
            "out": "Dica: deixe o endereço e a porta em branco se quiser definir usando <code> msg.ip </code> e <code> msg.port </code>.",
            "port": "Portas já em uso:"
        },
        "status": {
            "listener-at": "ouvinte udp em __host __: __ port__",
             "mc-group": "udp multicast group __group__",
             "listener-stopped": "udp ouvinte parado",
             "output-stopped": "saída udp interrompida",
             "mc-ready": "udp multicast pronto: __iface __: __ outport__ -> __host __: __ port__",
             "bc-ready": "transmissão udp pronta: __outport__ -> __host __: __ port__",
             "ready": "udp pronto: __outport__ -> __host __: __ porta__",
             "ready-nolocal": "udp ready: __host __: __ port__",
             "re-use": "udp re-use socket: __outport__ -> __host __: __ port__"
        },
        "errors": {
            "access-error": "Erro de acesso UDP, você pode precisar de acesso root para portas abaixo de 1024",
             "error": "erro: __error__",
             "bad-mcaddress": "Endereço Multicast Ruim",
             "interface": "Deve ser o endereço IP da interface necessária",
             "ip-notset": "udp: endereço ip não definido",
             "port-notset": "udp: porta não configurada",
             "port-invalid": "udp: número da porta não é válido",
             "alreadyused": "udp: porta __port__ já em uso",
             "ifnotfound": "udp: interface __iface__ não encontrada"
        }
    },
    "switch": {
        "switch": "interruptor",
        "label": {
            "property": "Propriedade",
            "rule": "regra",
            "repair": "recriar sequências de mensagens"
        },
        "previous": "valor anterior",
        "and": "e",
        "checkall": "checando todas as regras",
        "stopfirst": "parando após a primeiro match",
        "ignorecase": "ignorar caso",
        "rules": {
            "btwn": "está entre",
            "cont": "contém",
            "regex": "corresponde a regex",
            "true": "é verdadeiro",
            "false": "é falso",
            "null": "é nulo",
            "nnull": "não é nulo",
            "istype": "é do tipo",
            "empty": "está vazio",
            "nempty": "não está vazio",
            "head": "cabeça",
            "tail": "cauda",
            "index": "índice entre",
            "exp": "JSONata exp",
            "else": "caso contrário",
            "hask": "tem chave"
        },
        "errors": {
            "invalid-expr": "Expressão JSONata inválida: __error__",
             "too-many": "muitas mensagens pendentes no nó do switch"
        }
    },
    "change": {
        "label": {
            "rules": "Regras",
            "rule": "regra",
            "set": "definir __property__",
            "change": "alterar __property__",
            "delete": "delete __property__",
            "move": "mover __property__",
            "changeCount": "alterar: regras __count__",
            "regex": "Use expressões regulares"
        },
        "action": {
            "set": "Set",
            "change": "Mudar",
            "delete": "Delete",
            "move": "Mover",
            "to": "para",
            "search": "Search for",
            "replace": "Substituir por"
        },
        "errors": {
            "invalid-from": "Propriedade 'de' inválida: __error__",
            "invalid-json": "Propriedade 'para' JSON inválida",
            "invalid-expr": "Expressão JSONata inválida: __error__",
            "no-override": "Não é possível definir a propriedade do tipo não objeto: __property__"
        }
    },
    "range": {
        "range": "alcance",
        "label": {
            "action": "Ação",
             "inputrange": "Mapeie o intervalo de entrada",
             "resultrange": "para o intervalo alvo",
             "from": "de",
             "to": "para",
             "roundresult": "Arredonda o resultado para o número inteiro mais próximo?"
        },
        "placeholder": {
            "min": "ex: 0",
            "maxin": "ex: 99",
            "maxout": "ex: 255"
        },
        "scale": {
            "payload": "Dimensione a propriedade da mensagem",
            "limit": "Escala e limite para a faixa-alvo",
            "wrap": "Escala e quebra dentro do intervalo alvo"
        },
        "tip": "Dica: Este nó SÓ funciona com números.",
        "errors": {
            "notnumber": "Não é um número"
        }
    },
    "csv": {
        "label": {
            "columns": "Colunas",
            "separator": "Separador",
            "c2o": "CSV para opções de objeto",
            "o2c": "Objeto para opções CSV",
            "input": "Entrada",
            "skip-s": "Pular primeiro",
            "skip-e": "linhas",
            "firstrow": "a primeira linha contém os nomes das colunas",
            "output": "Saída",
            "includerow": "incluir linha de nome de coluna",
            "newline": "Nova linha",
            "usestrings": "analisar valores numéricos",
            "include_empty_strings": "incluir strings vazias",
            "include_null_values": "incluir valores nulos"
        },
        "placeholder": {
            "columns": "nomes de colunas separados por vírgulas"
        },
        "separator": {
            "comma": "vírgula",
             "tab": "tab",
             "space": "espaço",
             "semicolon": "ponto e vírgula",
             "colon": "dois pontos",
             "hashtag": "hashtag",
             "other": "outro..."
        },
        "output": {
            "row": "uma mensagem por linha",
            "array": "uma única mensagem [array]"
        },
        "newline": {
            "linux": "Linux (\\n)",
            "mac": "Mac (\\r)",
            "windows": "Windows (\\r\\n)"
        },
        "hdrout": {
            "none": "nunca enviar cabeçalhos de coluna",
             "all": "sempre enviar cabeçalhos de coluna",
             "once": "envia cabeçalhos uma vez, até msg.reset"
        },
        "errors": {
            "csv_js": "Este nó lida apenas com strings CSV ou objetos js.",
            "obj_csv": "Nenhum modelo de colunas especificado para o objeto -> CSV.",
            "bad_csv": "Dados CSV malformados - saída provavelmente corrompida."
        }
    },
    "html": {
        "label": {
            "select": "Seletor",
            "output": "Saída",
            "in": "em"
        },
        "output": {
            "html": "o conteúdo html dos elementos",
            "text": "apenas o conteúdo de texto dos elementos",
            "attr": "um objeto de quaisquer atributos dos elementos"
        },
        "format": {
            "single": "como uma única mensagem contendo uma matriz",
            "multi": "como mensagens múltiplas, uma para cada elemento"
        }
    },
    "json": {
        "errors": {
            "dropped-object": "Carga útil não objeto ignorada",
            "dropped": "Tipo de carga útil não suportado ignorado",
            "dropped-error": "Falha ao converter carga útil",
            "schema-error": "Erro de esquema JSON",
            "schema-error-compile": "Erro de esquema JSON: falha ao compilar o esquema"
        },
        "label": {
            "o2j": "Objeto para opções JSON",
            "pretty": "Formatar string JSON",
            "action": "Ação",
            "property": "Propriedade",  
            "actions": {
                "toggle": "Converter entre JSON String e Objeto",
                "str": "Sempre converter em string JSON",
                "obj": "Sempre converter para objeto JavaScript"
            }
        }
    },
    "yaml": {
        "errors": {
            "dropped-object": "Carga útil não objeto ignorada",
            "dropped": "Tipo de carga útil não suportado ignorado",
            "dropped-error": "Falha ao converter carga útil"
        }
    },
    "xml": {
        "label": {
            "represent": "Nome da propriedade para atributos de tag XML",
            "prefix": "Nome da propriedade para o conteúdo do texto da tag",
            "advanced": "Opções avançadas",
            "x2o": "Opções de XML para objeto"
        },
        "errors": {
            "xml_js": "Este nó lida apenas com strings xml ou objetos js."
        }
    },
    "file": {
        "label": {
            "filename": "Nome do arquivo",
            "action": "Ação",
            "addnewline": "Adicionar nova linha (\\n) a cada carga útil?",
            "createdir": "Criar diretório se não existir?",
            "outputas": "Output",
            "breakchunks": "Quebre em pedaços",
            "breaklines": "Quebra nas linhas",
            "filelabel": "arquivo",
            "sendError": "Enviar mensagem em caso de erro (modo legado)",
            "encoding": "Codificação",
            "deletelabel": "excluir __file__",
            "utf8String": "string UTF8",
            "utf8String_plural": "strings UTF8",
            "binaryBuffer": "buffer binário",
            "binaryBuffer_plural": "buffers binários",
            "allProps": "inclui todas as propriedades existentes em cada mensagem"
        },
        "action": {
            "append": "anexar ao arquivo",
            "overwrite": "sobrescrever file",
            "delete": "deletar file"
        },
        "output": {
            "utf8": "uma única string utf8",
            "buffer": "um único objeto Buffer",
            "lines": "uma mensagem por linha",
            "stream": "um stream de Buffers"
        },
        "status": {
            "wrotefile": "escreveu no arquivo: __file__",
             "deletedfile": "arquivo excluído: __file__",
             "appendedfile": "anexado ao arquivo: __file__"
        },
        "encoding": {
            "none": "padrão",
            "setbymsg": "definido por msg.encoding",
            "native": "Nativo",
            "unicode": "Unicode",
            "japanese": "japonês",
            "chinese": "chinês",
            "korean": "coreano",
            "taiwan": "Taiwan / Hong Kong",
            "windows": "páginas de código do Windows",
            "iso": "páginas de código ISO",
            "ibm": "páginas de código IBM",
            "mac": "páginas de código Mac",
            "koi8": "páginas de código KOI8",
            "misc": "Diversos"
        },
        "errors": {
            "nofilename": "Nenhum nome de arquivo especificado",
            "invaliddelete": "Aviso: exclusão inválida. Use a opção de exclusão específica na caixa de diálogo de configuração.",
            "deletefail": "falhou ao deletar o arquivo: __error__",
            "writefail": "falha ao gravar no arquivo: __error__",
            "appendfail": "falhou ao anexar ao arquivo: __error__",
            "createfail": "falhou ao criar o arquivo: __error__"
        },
        "tip": "Dica: O nome do arquivo deve ser um caminho absoluto, caso contrário, será relativo ao diretório de trabalho do processo Node-RED."
    },
    "split": {
        "split": "dividir",
         "intro": "Divida <code> msg.payload </code> com base no tipo:",
         "object": "<b> Objeto </b>",
         "objectSend": "Envia uma mensagem para cada par chave/valor",
         "strBuff": "<b>String</b> / <b>Buffer</b>",
         "array": "<b>Array</b>",
         "splitUsing": "Dividir usando",
         "splitLength": "Comprimento fixo de",
         "stream": "Tratar como um stream de mensagens",
         "addname": "Copiar chave para"
    },
    "join": {
        "join": "junte",
        "mode": {
            "mode": "Modo",
            "auto": "automático",
            "merge": "sequências de mesclagem",
            "reduce": "reduzir sequência",
            "custom": "manual"
        },
        "combine": "Combine cada",
        "completeMessage": "mensagem completa",
        "create": "para criar",
        "type": {
            "string": "uma String",
            "array": "um Array",
            "buffer": "um Buffer",
            "object": "um objeto chave/valor",
            "merged": "um objeto mesclado"
        },
        "using": "usando o valor de",
        "key": "como a chave",
        "joinedUsing": "juntou-se usando",
        "send": "Envie a mensagem:",
        "afterCount": "Depois de várias partes da mensagem",
        "count": "contar",
        "subsequent": "e todas as mensagens subsequentes.",
        "afterTimeout": "Após um tempo limite após a primeira mensagem",
        "seconds": "segundos",
        "complete": "Após uma mensagem com a propriedade <code> msg.complete </code> definida",
        "tip": "Este modo assume que este nó está emparelhado com um nó <i> dividido </i> ou as mensagens recebidas terão uma propriedade <code> msg.parts </code> configurada corretamente.",
        "too-many": "demasiadas mensagens pendentes no nó de junção",
        "merge": {
            "topics-label": "Tópicos mesclados",
             "topics": "tópicos",
             "topic": "tópico",
             "on-change": "Enviar mensagem mesclada na chegada de um novo tópico"
        },
        "reduce": {
            "exp": "Reduzir exp",
            "exp-value": "exp",
            "init": "Valor inicial",
            "right": "Avalie na ordem inversa (do último ao primeiro)",
            "fixup": "Exp de correção"
        },
        "errors": {
            "invalid-expr": "Expressão JSONata inválida: __error__",
            "invalid-type": "Não é possível juntar __error__ ao buffer"
        }
    },
    "sort" : {
        "sort": "ordenar",
        "target": "Classificar",
        "seq": "sequência de mensagens",
        "key": "Chave",
        "elem": "valor do elemento",
        "order": "Pedido",
        "ascending": "ascendente",
        "descending": "descendente",
        "as-number": "como número",
        "invalid-exp": "Expressão JSONata inválida no nó de classificação: __message__",
        "too-many": "Muitas mensagens pendentes no nó de classificação",
        "clear": "limpar a mensagem pendente no nó de classificação"
    },
    "batch" : {
        "batch": "lote",
        "mode": {
            "label": "Modo", 
            "num-msgs": "Agrupar por número de mensagens", 
            "interval": "Agrupar por intervalo de tempo", 
            "concat": "Concatenar sequências"
        },
        "count": {
            "label": "Número de mensagens",
            "overlap": "Sobreposição",
            "count": "contar",
            "invalid": "Contagem inválida e sobreposição"
        },
        "interval": {
            "label": "Intervalo",
            "seconds": "segundos",
            "empty": "enviar mensagem vazia quando nenhuma mensagem chegar"
        },
        "concat": {
            "topics-label": "Tópicos",
            "topic": "tópico"
        },
        "too-many": "demasiadas mensagens pendentes no nó de lote",
         "unexpected": "modo inesperado",
         "no-parts": "sem partes de propriedades na mensagem"
    },
    "rbe": {
        "rbe": "filtro",
        "label": {
            "func": "Modo",
            "init": "Enviar valor inicial",
            "start": "Valor inicial",
            "name": "Nome",
            "septopics": "Aplicar modo separadamente para cada"
        },
        "placeholder":{
            "bandgap": "por exemplo, 10 ou 5%",
            "start": "deixe em branco para usar os primeiros dados recebidos"
        },
        "opts": {
            "rbe": "bloquear a menos que o valor mude",
            "rbei": "bloquear a menos que o valor mude (ignorar o valor inicial)",
            "deadband": "bloquear a menos que a alteração do valor seja maior que",
            "deadbandEq": "bloquear a menos que a alteração do valor seja maior ou igual a",
            "narrowband": "bloquear se a alteração do valor for maior que",
            "narrowbandEq": "bloquear se a alteração do valor for maior ou igual a",
            "in": "em comparação com o último valor de entrada",
            "out": "em comparação com o último valor de saída válido"
        },
        "warn": {
            "nonumber": "nenhum número encontrado na carga útil"
        }
    }
}
